name: Azure Template Deployment

on: workflow_dispatch

jobs:
  deploy-infrastructure:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: ./.github/actions/azure-login
        with:
          azure-deploy-client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          azure-deploy-client-secret: ${{ secrets.AZURE_DEPLOY_CLIENT_SECRET }}
          azure-deploy-subscription-id: ${{ secrets.AZURE_DEPLOY_SUBSCRIPTION_ID }}
          azure-deploy-tenant-id: ${{ secrets.AZURE_DEPLOY_TENANT_ID }}

      - name: Create Resource Group
        run: |
          az deployment sub create `
            --location ${{ vars.AZURE_LOCATION }} `
            --template-file ./templates/resourceGroup.bicep `
            --parameters resourceGroupName=${{ vars.AZURE_RESOURCE_GROUP }} `
                         resourceGroupLocation=${{ vars.AZURE_LOCATION }}
        shell: pwsh

      - name: Register Resource Providers
        run: |
          az provider register --namespace Microsoft.OperationsManagement --wait
          az provider register --namespace Microsoft.OperationalInsights --wait
          az provider register --namespace Microsoft.DBforPostgreSQL --wait
          az provider register --namespace Microsoft.App --wait
        shell: pwsh

      - name: Generate Unique Names
        id: unique_names
        uses: ./.github/actions/create-unique-names
        with:
          resourceGroupName: ${{ vars.AZURE_RESOURCE_GROUP }}

      - name: Login to External ID Tenant (Proxy App)
        run: |
          az login --service-principal `
            --username ${{ secrets.EXTERNAL_ID_CLIENT_ID }} `
            --password ${{ secrets.EXTERNAL_ID_CLIENT_SECRET }} `
            --tenant ${{ secrets.EXTERNAL_ID_TENANT_ID }} `
            --allow-no-subscriptions
        shell: pwsh

      - name: Create Proxy App Registration
        id: proxy_app
        run: |
          $displayName = "${{ vars.PROXY_APP_DISPLAY_NAME }}"
          $callbackUrl = "https://${{ vars.PROXY_CUSTOM_DOMAIN_NAME }}/callback"
          $desiredAudience = "AzureADMyOrg"

          # Check if app registration already exists
          $existingApp = az ad app list --display-name $displayName --query "[0]" -o json | ConvertFrom-Json
          if ($existingApp) {
            if ($existingApp.signInAudience -ne $desiredAudience) {
              Write-Host "signInAudience is '$($existingApp.signInAudience)', need '$desiredAudience' - recreating app"
              az ad app delete --id $existingApp.appId
              Start-Sleep -Seconds 10
              $existingApp = $null
            } else {
              $objectId = $existingApp.id
              $appId = $existingApp.appId
              Write-Host "Proxy app registration already exists: $appId"
            }
          }

          if (-not $existingApp) {
            Write-Host "Creating new proxy app registration: $displayName"
            @{
              displayName = $displayName
              signInAudience = $desiredAudience
              web = @{
                redirectUris = @($callbackUrl)
              }
            } | ConvertTo-Json -Depth 5 | Set-Content -Path body.json
            $result = az rest --method POST `
              --uri "https://graph.microsoft.com/v1.0/applications" `
              --headers "Content-Type=application/json" `
              --body "@body.json" | ConvertFrom-Json
            $objectId = $result.id
            $appId = $result.appId

            Write-Host "Waiting for app registration to propagate..."
            Start-Sleep -Seconds 30

            az ad sp create --id $appId
          }

          # Ensure redirect URI is current (idempotent)
          @{
            web = @{
              redirectUris = @($callbackUrl)
            }
          } | ConvertTo-Json -Depth 5 | Set-Content -Path body.json
          az rest --method PATCH `
            --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
            --headers "Content-Type=application/json" `
            --body "@body.json"

          # Generate client secret (retry on Entra concurrency errors)
          $credential = $null
          for ($i = 1; $i -le 3; $i++) {
            Start-Sleep -Seconds 5
            $credential = az ad app credential reset --id $appId --query password -o tsv
            if ($LASTEXITCODE -eq 0) { break }
            Write-Host "Credential reset attempt $i failed, retrying..."
          }
          if ($LASTEXITCODE -ne 0) { throw "Failed to generate client secret after 3 attempts" }
          echo "::add-mask::$credential"

          Write-Host "Proxy App ID: $appId"
          echo "APP_ID=$appId" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "CLIENT_SECRET=$credential" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      - name: Re-login to Azure Subscription (Post Proxy App)
        uses: ./.github/actions/azure-login
        with:
          azure-deploy-client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          azure-deploy-client-secret: ${{ secrets.AZURE_DEPLOY_CLIENT_SECRET }}
          azure-deploy-subscription-id: ${{ secrets.AZURE_DEPLOY_SUBSCRIPTION_ID }}
          azure-deploy-tenant-id: ${{ secrets.AZURE_DEPLOY_TENANT_ID }}

      - name: Deploy Azure Resources
        run: |
          az deployment group create `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --template-file ./templates/azure-resources.bicep `
            --parameters acrName=${{ steps.unique_names.outputs.acrName }} `
                         logAnalyticsWorkspaceName=${{ steps.unique_names.outputs.logAnalyticsWorkspaceName }} `
                         applicationInsightsName=${{ steps.unique_names.outputs.applicationInsightsName }} `
                         postgresServerName=${{ steps.unique_names.outputs.postgresServerName }} `
                         postgresAdminPassword=${{ secrets.POSTGRES_ADMIN_PASSWORD }} `
                         dnsZoneName=${{ vars.DNS_ZONE_NAME }} `
                         containerAppEnvName=${{ steps.unique_names.outputs.containerAppEnvName }} `
                         proxyImage="ghcr.io/${{ vars.PROXY_GHCR_IMAGE }}:latest" `
                         proxyBaseUrl="https://${{ vars.PROXY_CUSTOM_DOMAIN_NAME }}" `
                         proxyEntraTenantId=${{ secrets.EXTERNAL_ID_TENANT_ID }} `
                         proxyEntraClientId=${{ steps.proxy_app.outputs.APP_ID }} `
                         proxyEntraClientSecret=${{ steps.proxy_app.outputs.CLIENT_SECRET }} `
                         proxyEntraAuthority="https://${{ vars.EXTERNAL_ID_TENANT_SUBDOMAIN }}.ciamlogin.com/${{ secrets.EXTERNAL_ID_TENANT_ID }}" `
                         apiImage="mcr.microsoft.com/k8se/quickstart:latest" `
                         uxImage="mcr.microsoft.com/k8se/quickstart:latest"
        shell: pwsh

      - name: Force New Auth Proxy Revision
        run: |
          # ACA updates secret values but doesn't create a new revision.
          # Force one so the container picks up the fresh client secret.
          $suffix = "deploy-" + (Get-Date -Format "yyyyMMddHHmmss")
          az containerapp update `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --name auth-proxy `
            --revision-suffix $suffix
        shell: pwsh

      - name: Print DNS Zone Name Servers
        run: |
          $deployment = az deployment group show `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --name azure-resources `
            --query "properties.outputs.dnsNameServers.value" `
            -o json | ConvertFrom-Json
          Write-Host "=== DNS Zone Name Servers ==="
          Write-Host "Configure these NS records at your domain registrar:"
          $deployment | ForEach-Object { Write-Host "  $_" }
        shell: pwsh

      - name: Get Container App FQDNs
        id: container_apps
        run: |
          $apiAppFqdn = az deployment group show `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --name azure-resources `
            --query "properties.outputs.apiContainerAppFqdn.value" `
            -o tsv
          Write-Host "API Container App FQDN: $apiAppFqdn"
          echo "API_FQDN=$apiAppFqdn" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          $uxAppFqdn = az deployment group show `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --name azure-resources `
            --query "properties.outputs.uxContainerAppFqdn.value" `
            -o tsv
          Write-Host "UX Container App FQDN: $uxAppFqdn"
          echo "UX_FQDN=$uxAppFqdn" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          $authAppFqdn = az deployment group show `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --name azure-resources `
            --query "properties.outputs.authProxyContainerAppFqdn.value" `
            -o tsv
          Write-Host "Auth Proxy Container App FQDN: $authAppFqdn"
          echo "AUTH_FQDN=$authAppFqdn" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      - name: Clean Up Old Front Door Resources
        run: |
          # Remove legacy routes/origins that conflict with the new 3-origin config.
          # Bicep incremental mode doesn't delete resources removed from the template.
          $profileName = "MyFrontDoor"
          $rg = "${{ vars.AZURE_RESOURCE_GROUP }}"

          # Delete old route if it exists
          az afd route delete `
            --resource-group $rg `
            --profile-name $profileName `
            --endpoint-name ${{ steps.unique_names.outputs.frontDoorEndpointName }} `
            --route-name MyRoute --yes 2>$null

          # Delete old origin (must delete before origin group)
          az afd origin delete `
            --resource-group $rg `
            --profile-name $profileName `
            --origin-group-name MyOriginGroup `
            --origin-name MyOrigin --yes 2>$null

          # Delete old origin group
          az afd origin-group delete `
            --resource-group $rg `
            --profile-name $profileName `
            --origin-group-name MyOriginGroup --yes 2>$null

          # Delete old custom domain resource if it exists
          $oldDomainName = "${{ vars.CUSTOM_DOMAIN_NAME }}" -replace '\.', '-'
          az afd custom-domain delete `
            --resource-group $rg `
            --profile-name $profileName `
            --custom-domain-name $oldDomainName --yes 2>$null

          Write-Host "Old Front Door resources cleaned up"
        shell: pwsh
        continue-on-error: true

      - name: Deploy Front Door
        run: |
          az deployment group create `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --template-file ./templates/front-door-resources.bicep `
            --parameters endpointName=${{ steps.unique_names.outputs.frontDoorEndpointName }} `
                         appCustomDomainName=${{ vars.CUSTOM_DOMAIN_NAME }} `
                         authCustomDomainName=${{ vars.PROXY_CUSTOM_DOMAIN_NAME }} `
                         apiOriginHostName=${{ steps.container_apps.outputs.API_FQDN }} `
                         uxOriginHostName=${{ steps.container_apps.outputs.UX_FQDN }} `
                         authOriginHostName=${{ steps.container_apps.outputs.AUTH_FQDN }}
        shell: pwsh

      - name: Create CNAME Records
        run: |
          $afdHostName = "${{ steps.unique_names.outputs.frontDoorEndpointName }}.z01.azurefd.net"

          # App subdomain CNAME (e.g. app → AFD)
          $appSubdomain = "${{ vars.CUSTOM_DOMAIN_NAME }}".Split('.')[0]
          az network dns record-set cname set-record `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --zone-name ${{ vars.DNS_ZONE_NAME }} `
            --record-set-name $appSubdomain `
            --cname $afdHostName

          # Auth subdomain CNAME (e.g. auth → AFD)
          $authSubdomain = "${{ vars.PROXY_CUSTOM_DOMAIN_NAME }}".Split('.')[0]
          az network dns record-set cname set-record `
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} `
            --zone-name ${{ vars.DNS_ZONE_NAME }} `
            --record-set-name $authSubdomain `
            --cname $afdHostName
        shell: pwsh

      - name: Configure AFD Custom Domain DNS Validation
        run: |
          # Validate app custom domain
          $appCustomDomain = "${{ vars.CUSTOM_DOMAIN_NAME }}"
          $appAfdDomainName = $appCustomDomain -replace '\.', '-'
          $appSubdomain = $appCustomDomain.Split('.')[0]
          ./tools/SetAfdDnsValidation.ps1 `
            -ResourceGroup ${{ vars.AZURE_RESOURCE_GROUP }} `
            -FrontDoorProfileName MyFrontDoor `
            -CustomDomainName $appAfdDomainName `
            -DnsZoneName ${{ vars.DNS_ZONE_NAME }} `
            -DnsZoneResourceGroup ${{ vars.AZURE_RESOURCE_GROUP }} `
            -Subdomain $appSubdomain

          # Validate auth custom domain
          $authCustomDomain = "${{ vars.PROXY_CUSTOM_DOMAIN_NAME }}"
          $authAfdDomainName = $authCustomDomain -replace '\.', '-'
          $authSubdomain = $authCustomDomain.Split('.')[0]
          ./tools/SetAfdDnsValidation.ps1 `
            -ResourceGroup ${{ vars.AZURE_RESOURCE_GROUP }} `
            -FrontDoorProfileName MyFrontDoor `
            -CustomDomainName $authAfdDomainName `
            -DnsZoneName ${{ vars.DNS_ZONE_NAME }} `
            -DnsZoneResourceGroup ${{ vars.AZURE_RESOURCE_GROUP }} `
            -Subdomain $authSubdomain
        shell: pwsh

      - name: Login to External ID Tenant
        run: |
          az login --service-principal `
            --username ${{ secrets.EXTERNAL_ID_CLIENT_ID }} `
            --password ${{ secrets.EXTERNAL_ID_CLIENT_SECRET }} `
            --tenant ${{ secrets.EXTERNAL_ID_TENANT_ID }} `
            --allow-no-subscriptions
        shell: pwsh

      - name: Create SPA App Registration
        id: spa_app
        run: |
          $displayName = "${{ vars.SPA_APP_DISPLAY_NAME }}"
          $customDomain = "${{ vars.CUSTOM_DOMAIN_NAME }}"

          # Check if app registration already exists
          $existingApp = az ad app list --display-name $displayName --query "[0]" -o json | ConvertFrom-Json
          if ($existingApp) {
            $objectId = $existingApp.id
            $appId = $existingApp.appId
            Write-Host "Updating existing app registration: $objectId"
            @{
              spa = @{
                redirectUris = @(
                  "https://${customDomain}/app",
                  "http://localhost:3000/app"
                )
              }
            } | ConvertTo-Json -Depth 5 | Set-Content -Path body.json
            az rest --method PATCH `
              --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
              --headers "Content-Type=application/json" `
              --body "@body.json"
          } else {
            Write-Host "Creating new app registration: $displayName"
            @{
              displayName = $displayName
              signInAudience = "AzureADandPersonalMicrosoftAccount"
              spa = @{
                redirectUris = @(
                  "https://${customDomain}/app",
                  "http://localhost:3000/app"
                )
              }
            } | ConvertTo-Json -Depth 5 | Set-Content -Path body.json
            $result = az rest --method POST `
              --uri "https://graph.microsoft.com/v1.0/applications" `
              --headers "Content-Type=application/json" `
              --body "@body.json" | ConvertFrom-Json
            $appId = $result.appId
          }
          Write-Host "SPA App ID: $appId"
          echo "APP_ID=$appId" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      - name: Create User Flow
        id: user_flow
        run: |
          $tenantId = "${{ secrets.EXTERNAL_ID_TENANT_ID }}"
          $accessToken = az account get-access-token `
            --resource-type ms-graph `
            --query accessToken -o tsv

          # Check if user flow already exists
          $existingFlows = Invoke-RestMethod `
            -Uri "https://graph.microsoft.com/v1.0/identity/authenticationEventsFlows" `
            -Headers @{ Authorization = "Bearer $accessToken" } `
            -Method Get

          $flowExists = $existingFlows.value | Where-Object { $_.displayName -eq "Sign up and sign in" }

          if (-not $flowExists) {
            Write-Host "Creating sign-up/sign-in user flow"
            $body = @{
              "@odata.type" = "#microsoft.graph.externalUsersSelfServiceSignUpEventsFlow"
              displayName = "Sign up and sign in"
              onAuthenticationMethodLoadStart = @{
                "@odata.type" = "#microsoft.graph.onAuthenticationMethodLoadStartExternalUsersSelfServiceSignUp"
                identityProviders = @(
                  @{
                    "@odata.type" = "#microsoft.graph.builtInIdentityProvider"
                    id = "EmailPassword-OAUTH"
                  }
                )
              }
            } | ConvertTo-Json -Depth 10

            $result = Invoke-RestMethod `
              -Uri "https://graph.microsoft.com/v1.0/identity/authenticationEventsFlows" `
              -Headers @{
                Authorization = "Bearer $accessToken"
                "Content-Type" = "application/json"
              } `
              -Method Post `
              -Body $body
            $flowId = $result.id
          } else {
            Write-Host "User flow already exists, skipping creation"
            $flowId = $flowExists.id
          }
          Write-Host "User Flow ID: $flowId"
          echo "FLOW_ID=$flowId" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      - name: Create Service Principal for SPA App
        run: |
          $appId = "${{ steps.spa_app.outputs.APP_ID }}"

          # Check if service principal already exists
          $existingSp = az ad sp list --filter "appId eq '$appId'" --query "[0]" -o json | ConvertFrom-Json
          if (-not $existingSp) {
            Write-Host "Creating service principal for app $appId"
            az ad sp create --id $appId
          } else {
            Write-Host "Service principal already exists, skipping"
          }
        shell: pwsh

      - name: Grant Admin Consent for SPA App
        run: |
          $appId = "${{ steps.spa_app.outputs.APP_ID }}"
          $spId = (az ad sp list --filter "appId eq '$appId'" --query "[0].id" -o tsv)

          $accessToken = az account get-access-token `
            --resource-type ms-graph `
            --query accessToken -o tsv

          # Microsoft Graph service principal (well-known appId)
          $graphAppId = "00000003-0000-0000-c000-000000000000"
          $graphSp = (az ad sp list --filter "appId eq '$graphAppId'" --query "[0]" -o json | ConvertFrom-Json)
          $graphSpId = $graphSp.id

          # Find the oauth2PermissionScopes for openid, profile, offline_access
          $scopes = @("openid", "profile", "offline_access")
          $scopeIds = @()
          foreach ($scope in $scopes) {
            $scopeId = ($graphSp.oauth2PermissionScopes | Where-Object { $_.value -eq $scope }).id
            if ($scopeId) { $scopeIds += $scopeId }
          }

          # Check if consent grant already exists
          $existingGrants = Invoke-RestMethod `
            -Uri "https://graph.microsoft.com/v1.0/oauth2PermissionGrants?`$filter=clientId eq '$spId' and resourceId eq '$graphSpId'" `
            -Headers @{ Authorization = "Bearer $accessToken" } `
            -Method Get

          if ($existingGrants.value.Count -eq 0) {
            Write-Host "Granting admin consent for openid, profile, offline_access"
            $body = @{
              clientId = $spId
              consentType = "AllPrincipals"
              resourceId = $graphSpId
              scope = ($scopes -join " ")
            } | ConvertTo-Json

            Invoke-RestMethod `
              -Uri "https://graph.microsoft.com/v1.0/oauth2PermissionGrants" `
              -Headers @{
                Authorization = "Bearer $accessToken"
                "Content-Type" = "application/json"
              } `
              -Method Post `
              -Body $body
            Write-Host "Admin consent granted successfully"
          } else {
            Write-Host "Admin consent already granted, skipping"
          }
        shell: pwsh

      - name: Link App to User Flow
        run: |
          $accessToken = az account get-access-token `
            --resource-type ms-graph `
            --query accessToken -o tsv

          $flowId = "${{ steps.user_flow.outputs.FLOW_ID }}"
          $appId = "${{ steps.spa_app.outputs.APP_ID }}"

          # Check if app is already linked to the flow
          $linkedApps = Invoke-RestMethod `
            -Uri "https://graph.microsoft.com/v1.0/identity/authenticationEventsFlows/$flowId/conditions/applications/includeApplications" `
            -Headers @{ Authorization = "Bearer $accessToken" } `
            -Method Get

          $alreadyLinked = $linkedApps.value | Where-Object { $_.appId -eq $appId }

          if (-not $alreadyLinked) {
            Write-Host "Linking app $appId to user flow $flowId"
            $body = @{
              "@odata.type" = "#microsoft.graph.authenticationConditionApplication"
              appId = $appId
            } | ConvertTo-Json

            Invoke-RestMethod `
              -Uri "https://graph.microsoft.com/v1.0/identity/authenticationEventsFlows/$flowId/conditions/applications/includeApplications" `
              -Headers @{
                Authorization = "Bearer $accessToken"
                "Content-Type" = "application/json"
              } `
              -Method Post `
              -Body $body
            Write-Host "App linked to user flow successfully"
          } else {
            Write-Host "App already linked to user flow, skipping"
          }
        shell: pwsh

      - name: Create API App Registration
        id: api_app
        run: |
          $displayName = "${{ vars.API_APP_DISPLAY_NAME }}"
          $desiredAudience = "AzureADMyOrg"

          # Check if app registration already exists
          $existingApp = az ad app list --display-name $displayName --query "[0]" -o json | ConvertFrom-Json
          if ($existingApp) {
            # If existing app has wrong signInAudience, delete and recreate
            # (Entra blocks downgrading from AzureADandPersonalMicrosoftAccount)
            if ($existingApp.signInAudience -ne $desiredAudience) {
              Write-Host "signInAudience is '$($existingApp.signInAudience)', need '$desiredAudience' - recreating app"
              az ad app delete --id $existingApp.appId
              Start-Sleep -Seconds 10
              $existingApp = $null
            } else {
              $objectId = $existingApp.id
              $appId = $existingApp.appId
              Write-Host "API app registration already exists: $appId"
            }
          }

          if (-not $existingApp) {
            Write-Host "Creating new API app registration: $displayName"
            @{
              displayName = $displayName
              signInAudience = $desiredAudience
            } | ConvertTo-Json -Depth 5 | Set-Content -Path body.json
            $result = az rest --method POST `
              --uri "https://graph.microsoft.com/v1.0/applications" `
              --headers "Content-Type=application/json" `
              --body "@body.json" | ConvertFrom-Json
            $objectId = $result.id
            $appId = $result.appId

            # Wait for Entra replication before updating the app
            Write-Host "Waiting for app registration to propagate..."
            Start-Sleep -Seconds 30
          }

          # Set identifier URI (idempotent)
          @{
            identifierUris = @("api://$appId")
          } | ConvertTo-Json -Depth 5 | Set-Content -Path body.json
          az rest --method PATCH `
            --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
            --headers "Content-Type=application/json" `
            --body "@body.json"

          # Add mcp.access scope if not present
          $app = az rest --method GET `
            --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
            --headers "Content-Type=application/json" | ConvertFrom-Json
          $existingScope = $app.api.oauth2PermissionScopes | Where-Object { $_.value -eq "mcp.access" }

          if (-not $existingScope) {
            Write-Host "Adding mcp.access scope"
            $scopeId = [guid]::NewGuid().ToString()
            @{
              api = @{
                oauth2PermissionScopes = @(
                  @{
                    id = $scopeId
                    adminConsentDisplayName = "Access MCP API"
                    adminConsentDescription = "Allows MCP clients to access the nutrition tracking API"
                    userConsentDisplayName = "Access MCP API"
                    userConsentDescription = "Allows MCP clients to access the nutrition tracking API"
                    value = "mcp.access"
                    type = "User"
                    isEnabled = $true
                  }
                )
              }
            } | ConvertTo-Json -Depth 10 | Set-Content -Path body.json
            az rest --method PATCH `
              --uri "https://graph.microsoft.com/v1.0/applications/$objectId" `
              --headers "Content-Type=application/json" `
              --body "@body.json"
          } else {
            Write-Host "mcp.access scope already exists, skipping"
          }

          Write-Host "API App ID: $appId"
          echo "APP_ID=$appId" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      - name: Create Service Principal for API App
        run: |
          $appId = "${{ steps.api_app.outputs.APP_ID }}"

          # Check if service principal already exists
          $existingSp = az ad sp list --filter "appId eq '$appId'" --query "[0]" -o json | ConvertFrom-Json
          if (-not $existingSp) {
            Write-Host "Creating service principal for API app $appId"
            az ad sp create --id $appId
          } else {
            Write-Host "Service principal already exists, skipping"
          }
        shell: pwsh

      - name: Re-login to Azure Subscription
        uses: ./.github/actions/azure-login
        with:
          azure-deploy-client-id: ${{ secrets.AZURE_DEPLOY_CLIENT_ID }}
          azure-deploy-client-secret: ${{ secrets.AZURE_DEPLOY_CLIENT_SECRET }}
          azure-deploy-subscription-id: ${{ secrets.AZURE_DEPLOY_SUBSCRIPTION_ID }}
          azure-deploy-tenant-id: ${{ secrets.AZURE_DEPLOY_TENANT_ID }}
